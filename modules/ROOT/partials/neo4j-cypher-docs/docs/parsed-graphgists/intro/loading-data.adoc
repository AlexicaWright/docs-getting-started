[[cypherdoc-loading-data]]
= Loading Data =










As you've seen, you are able not only to query data expressively, but can also create data with Cypher statements.


Naturally in most cases you wouldn't want to write or generate huge statements to generate your data but instead use an existing data source that you pass into your statement and which is used to drive the graph generation process.


That process not only includes creating completely new data but also integrating with existing structures and updating your graph.


[[cypher-intro-load-parameters]]
== Parameters


In general we recommend passing in varying literal values from the outside as named parameters.
This allows Cypher to reuse existing execution plans for the statements.


Of course you can also pass in parameters for data to be imported.
These can be scalar values, maps, lists or even lists of maps.


In your Cypher statement you can then iterate over those values (e.g. with `UNWIND`) to create your graph structures.


For instance to create a movie graph from JSON data structures pulled from an API you could use:



[source,json]
----
{
  "movies" : [ {
    "title" : "Stardust",
    "released" : 2007,
    "cast" : [ {
      "actor" : {
        "name" : "Robert de Niro",
        "born" : 1943
      },
      "characters" : [ "Captain Shakespeare" ]
    }, {
      "actor" : {
        "name" : "Michelle Pfeiffer",
        "born" : 1958
      },
      "characters" : [ "Lamia" ]
    } ]
  } ]
}
----



[source,cypher-noexec]
----
UNWIND $movies as movie
MERGE (m:Movie {title:movie.title}) ON CREATE SET m.released = movie.released
FOREACH (role IN movie.cast |
   MERGE (a:Person {name:role.actor.name}) ON CREATE SET a.born = role.actor.born
   MERGE (a)-[:ACTED_IN {roles:role.characters}]->(m)
)
----




[[cypher-intro-importing-csv]]
== Importing CSV


Cypher provides an elegant built-in way to import tabular CSV data into graph structures.


The `LOAD CSV` clause parses a local or remote file into a stream of rows which represent maps (with headers) or lists.
Then you can use whatever Cypher operations you want to apply to either create nodes or relationships or to merge with existing graph structures.


As CSV files usually represent either node- or relationship-lists, you run multiple passes to create nodes and relationships separately.


For more details, see <<query-load-csv>>.


.movies.csv
[source]
----
include::../../graphgists/intro/movies.csv[]
----


[source,cypher]
----
LOAD CSV WITH HEADERS FROM "{csv-dir}/intro/movies.csv" AS line
CREATE (m:Movie { id: line.id, title: line.title, released: toInteger(line.year)});
----




.persons.csv
[source]
----
include::../../graphgists/intro/persons.csv[]
----


[source,cypher]
----
LOAD CSV WITH HEADERS FROM "{csv-dir}/intro/persons.csv" AS line
MERGE (a:Person { id: line.id })
ON CREATE SET a.name = line.name;
----




.roles.csv
[source]
----
include::../../graphgists/intro/roles.csv[]
----


[source,cypher]
----
LOAD CSV WITH HEADERS FROM "{csv-dir}/intro/roles.csv" AS line
MATCH (m:Movie { id: line.movieId })
MATCH (a:Person { id: line.personId })
CREATE (a)-[:ACTED_IN { roles: [line.role]}]->(m);
----




["dot", "cypherdoc--d7de47ee.svg", "neoviz"]
----
  N0 [
    label = "{Movie|released = 1987\lid = \'1\'\ltitle = \'Wall Street\'\l}"
  ]
  N1 [
    label = "{Movie|title = \'The American President\'\lreleased = 1995\lid = \'2\'\l}"
  ]
  N2 [
    label = "{Movie|title = \'The Shawshank Redemption\'\lreleased = 1994\lid = \'3\'\l}"
  ]
  N3 [
    label = "{Person|name = \'Charlie Sheen\'\lid = \'1\'\l}"
  ]
  N3 -> N0 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'Bud Fox\'\]\l"
  ]
  N4 [
    label = "{Person|name = \'Oliver Stone\'\lid = \'2\'\l}"
  ]
  N5 [
    label = "{Person|name = \'Michael Douglas\'\lid = \'3\'\l}"
  ]
  N5 -> N0 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'Gordon Gekko\'\]\l"
  ]
  N5 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'President Andrew Shepherd\'\]\l"
  ]
  N6 [
    label = "{Person|name = \'Martin Sheen\'\lid = \'4\'\l}"
  ]
  N6 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'A.J. MacInerney\'\]\l"
  ]
  N6 -> N0 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'Carl Fox\'\]\l"
  ]
  N7 [
    label = "{Person|name = \'Morgan Freeman\'\lid = \'5\'\l}"
  ]
  N7 -> N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'Ellis Boyd \\\\\'Red\\\\\' Redding\'\]\l"
  ]
----


If your file contains denormalized data, you can either run the same file with multiple passes and simple operations as shown above or you might have to use `MERGE` to create entities uniquely.


For our use-case we can import the data using a CSV structure like this:


.movie_actor_roles.csv
[source]
----
include::../../graphgists/intro/movie_actor_roles.csv[]
----


[source,cypher]
----
LOAD CSV WITH HEADERS FROM "{csv-dir}/intro/movie_actor_roles.csv" AS line FIELDTERMINATOR ";"
MERGE (m:Movie { title: line.title })
ON CREATE SET m.released = toInteger(line.released)
MERGE (a:Person { name: line.actor })
ON CREATE SET a.born = toInteger(line.born)
MERGE (a)-[:ACTED_IN { roles:split(line.characters, ',')}]->(m)
----




["dot", "cypherdoc--df29f0ca.svg", "neoviz"]
----
  N0 [
    label = "{Movie|released = 1987\lid = \'1\'\ltitle = \'Wall Street\'\l}"
  ]
  N1 [
    label = "{Movie|title = \'The American President\'\lreleased = 1995\lid = \'2\'\l}"
  ]
  N2 [
    label = "{Movie|title = \'The Shawshank Redemption\'\lreleased = 1994\lid = \'3\'\l}"
  ]
  N3 [
    label = "{Person|name = \'Charlie Sheen\'\lid = \'1\'\l}"
  ]
  N3 -> N0 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'Bud Fox\'\]\l"
  ]
  N4 [
    label = "{Person|name = \'Oliver Stone\'\lid = \'2\'\l}"
  ]
  N5 [
    label = "{Person|name = \'Michael Douglas\'\lid = \'3\'\l}"
  ]
  N5 -> N0 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'Gordon Gekko\'\]\l"
  ]
  N5 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'President Andrew Shepherd\'\]\l"
  ]
  N6 [
    label = "{Person|name = \'Martin Sheen\'\lid = \'4\'\l}"
  ]
  N6 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'A.J. MacInerney\'\]\l"
  ]
  N6 -> N0 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'Carl Fox\'\]\l"
  ]
  N7 [
    label = "{Person|name = \'Morgan Freeman\'\lid = \'5\'\l}"
  ]
  N7 -> N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'Ellis Boyd \\\\\'Red\\\\\' Redding\'\]\l"
  ]
  N8 [
    label = "{Movie|released = 1985\ltitle = \'Back to the Future\'\l}"
  ]
  N9 [
    label = "{Person|name = \'Michael J. Fox\'\lborn = 1961\l}"
  ]
  N9 -> N8 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'Marty McFly\'\]\l"
  ]
  N10 [
    label = "{Person|name = \'Christopher Lloyd\'\lborn = 1938\l}"
  ]
  N10 -> N8 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nroles = \[\'Dr. Emmet Brown\'\]\l"
  ]
----


If you import a large amount of data (more than 10000 rows), it is recommended to prefix your `LOAD CSV` clause with a `PERIODIC COMMIT` hint.
This allows Neo4j to regularly commit the import transactions to avoid memory churn for large transaction-states.


ifndef::backend-pdf[]
ifdef::backend-html,backend-html5,backend-xhtml11,backend-deckjs[]
++++
<p class="cypherdoc-console"></p>
++++
endif::[]
endif::[]
ifndef::backend-pdf[]
ifndef::backend-html,backend-html5,backend-xhtml11,backend-deckjs[]
++++
<simpara role="cypherdoc-console"></simpara>
++++
endif::[]
endif::[]
