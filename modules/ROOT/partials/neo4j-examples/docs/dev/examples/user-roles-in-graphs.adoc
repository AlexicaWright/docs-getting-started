[[examples-user-roles-in-graphs]]
User roles in graphs
====================

This is an example showing a hierarchy of
roles.
What's interesting is that a tree is not sufficient for storing this kind of structure,
as elaborated below.

image::roles.png[]

This is an implementation of an example found in the article
http://www.codeproject.com/Articles/22824/A-Model-to-Represent-Directed-Acyclic-Graphs-DAG-o[A Model to Represent Directed Acyclic Graphs (DAG) on SQL Databases]
by http://www.codeproject.com/script/Articles/MemberArticles.aspx?amid=274518[Kemal Erdogan].
The article discusses how to store http://en.wikipedia.org/wiki/Directed_acyclic_graph[
directed acyclic graphs] (DAGs)
in SQL based DBs. DAGs are almost trees, but with a twist: it may be possible to reach
the same node through different paths. Trees are restricted from this possibility, which
makes them much easier to handle. In our case it is ``Ali'' and ``Engin'',
as they are both admins and users and thus reachable through these group nodes.
Reality often looks this way and can't be captured by tree structures.

In the article an SQL Stored Procedure solution is provided. The main idea,
that also have some support from scientists, is to pre-calculate all possible (transitive) paths.
Pros and cons of this approach:

* decent performance on read
* low performance on insert
* wastes _lots_ of space
* relies on stored procedures

In Neo4j storing the roles is trivial. In this case we use +PART_OF+ (green edges) relationships
to model the group hierarchy and +MEMBER_OF+ (blue edges) to model membership in groups.
We also connect the top level groups to the reference node by +ROOT+ relationships.
This gives us a useful partitioning of the graph. Neo4j has no predefined relationship
types, you are free to create any relationship types and give them the semantics you want.

Lets now have a look at how to retrieve information from the graph. The the queries are done using <<cypher, Cypher>>,
the Java code is using the Neo4j Traversal API (see <<tutorial-traversal-java-api>>, which is part of <<advanced-usage>>).

== Get the admins ==

In Cypher, we could get the admins like this:

include::includes/user-roles-in-graphs-query-get-admins.adoc[]

resulting in:

include::includes/user-roles-in-graphs-o-query-get-admins.adoc[]

And here's the code when using the Java Traversal API:

include::includes/user-roles-in-graphs-get-admins.adoc[]

resulting in the output

include::includes/user-roles-in-graphs-o-get-admins.adoc[]

The result is collected from the traverser using this code:

include::includes/user-roles-in-graphs-read-traverser.adoc[]

== Get the group memberships of a user ==

In Cypher:

include::includes/user-roles-in-graphs-query-get-user-memberships.adoc[]

include::includes/user-roles-in-graphs-o-query-get-user-memberships.adoc[]

Using the Neo4j Java Traversal API, this query looks like:

include::includes/user-roles-in-graphs-get-user-memberships.adoc[]

resulting in:

include::includes/user-roles-in-graphs-o-get-user-memberships.adoc[]

== Get all groups ==

In Cypher:

include::includes/user-roles-in-graphs-query-get-groups.adoc[]

include::includes/user-roles-in-graphs-o-query-get-groups.adoc[]

In Java:

include::includes/user-roles-in-graphs-get-groups.adoc[]

resulting in:

include::includes/user-roles-in-graphs-o-get-groups.adoc[]

== Get all members of all groups ==

Now, let's try to find all users in the system being part of any group.

In Cypher, this looks like:

include::includes/user-roles-in-graphs-query-get-members.adoc[]

and results in the following output:

include::includes/user-roles-in-graphs-o-query-get-members.adoc[]

in Java:

include::includes/user-roles-in-graphs-get-members.adoc[]

include::includes/user-roles-in-graphs-o-get-members.adoc[]

As seen above, querying even more complex scenarios can be done using comparatively short
constructs in Cypher or Java.


